<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Dispatcher.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../../versions.js"></script><link href="../assets/invenia.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Dispatcher.jl</h1><form class="search" action="../search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="manual.html">Manual</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"><li><a class="toctext" href="#Nodes-1">Nodes</a></li><li><a class="toctext" href="#Graph-1">Graph</a></li><li><a class="toctext" href="#Context-1">Context</a></li><li><a class="toctext" href="#Executors-1">Executors</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/docs/src/pages/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><h2><a class="nav-anchor" id="Nodes-1" href="#Nodes-1">Nodes</a></h2><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DispatchNode" href="#Dispatcher.DispatchNode"><code>Dispatcher.DispatchNode</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>DispatchNode</code> represents a unit of computation that can be run. A <code>DispatchNode</code> may depend on other <code>DispatchNode</code>s, which are returned from the <code>dependencies</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L20-L24">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Op" href="#Dispatcher.Op"><code>Dispatcher.Op</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An <code>Op</code> is a <code>DispatchNode</code> which wraps a function which is executed when the <code>Op</code> is run. The result of that function call is stored in the <code>result</code> <code>DeferredFuture</code>. Any <code>DispatchNode</code>s which appear in the args or kwargs values will be noted as dependencies. This is the most common <code>DispatchNode</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L88-L94">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DataNode" href="#Dispatcher.DataNode"><code>Dispatcher.DataNode</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A <code>DataNode</code> is a <code>DispatchNode</code> which wraps a piece of static data.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L74-L76">source</a><br/></section><h3><a class="nav-anchor" id="Functions-and-Macros-1" href="#Functions-and-Macros-1">Functions and Macros</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dependencies" href="#Dispatcher.dependencies"><code>Dispatcher.dependencies</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dependencies(node::DispatchNode) -&gt; Tuple{Vararg{DispatchNode}}</code></pre><p>Return all dependencies which must be ready before executing this node. Unless given a <code>dependencies</code> method, a <code>DispatchNode</code> will be assumed to have no dependencies.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L44-L50">source</a><br/><div><pre><code class="language-none">dependencies(op::Op) -&gt; Tuple{Verarg{DispatchNode}}</code></pre><p>Return all dependencies which must be ready before executing this <code>Op</code>. This will be all <code>DispatchNode</code>s in the <code>Op</code>&#39;s function <code>args</code> and <code>kwargs</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L104-L109">source</a><br/><div><pre><code class="language-none">dependencies(node::IndexNode) -&gt; Tuple{DispatchNode}</code></pre><p>Return the dependency that this node will fetch data (at a certain index) from.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L214-L218">source</a><br/><div><pre><code class="language-none">dependencies(node::CleanupNode) -&gt; Tuple{Vararg{DispatchNode}}</code></pre><p>Return the nodes the <code>CleanupNode</code> must wait for before cleaning up (the parent and child nodes).</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L293-L298">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.@op" href="#Dispatcher.@op"><code>Dispatcher.@op</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@op func(...)</code></pre><p>The <code>@op</code> macro makes it more convenient to add <code>Op</code> nodes to the computation graph while in a <code>@dispatch_context</code> block. It translates a function call into an <code>Op</code> call, effectively deferring the computation.</p><pre><code class="language-julia">a = @op sort(1:10; rev=true)</code></pre><p>is equivalent to</p><pre><code class="language-julia">a = add!(ctx, Op(sort, 1:10; rev=true))</code></pre><p>where <code>ctx</code> is a variable created by the surrounding <code>@dispatch_context</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/macros.jl#L20-L35">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.@node" href="#Dispatcher.@node"><code>Dispatcher.@node</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@node Node(...)</code></pre><p>The <code>@node</code> macro makes it more convenient to add nodes to the computation graph while in a <code>@dispatch_context</code> block.</p><pre><code class="language-julia">a = @node DataNode([1, 3, 5])</code></pre><p>is equivalent to</p><pre><code class="language-julia">a = add!(ctx, DataNode([1, 3, 5]))</code></pre><p>where <code>ctx</code> is a variable created by the surrounding <code>@dispatch_context</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/macros.jl#L1-L15">source</a><br/></section><h2><a class="nav-anchor" id="Graph-1" href="#Graph-1">Graph</a></h2><h3><a class="nav-anchor" id="Types-2" href="#Types-2">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DispatchGraph" href="#Dispatcher.DispatchGraph"><code>Dispatcher.DispatchGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>DispatchGraph</code> wraps a directed graph from <code>LightGraphs</code> and a bidirectional dictionary mapping between <code>DispatchNode</code> instances and vertex numbers in the graph.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/graph.jl#L1-L5">source</a><br/></section><h3><a class="nav-anchor" id="Functions-and-Macros-2" href="#Functions-and-Macros-2">Functions and Macros</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.nodes-Tuple{Dispatcher.DispatchGraph}" href="#Dispatcher.nodes-Tuple{Dispatcher.DispatchGraph}"><code>Dispatcher.nodes</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">nodes(graph::DispatchGraph) -&gt;</code></pre><p>Return an iterable of all nodes stored in the <code>DispatchGraph</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/graph.jl#L51-L55">source</a><br/></section><h2><a class="nav-anchor" id="Context-1" href="#Context-1">Context</a></h2><h3><a class="nav-anchor" id="Types-3" href="#Types-3">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.DispatchContext" href="#Dispatcher.DispatchContext"><code>Dispatcher.DispatchContext</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>DispatchContext</code> holds the computation graph and arbitrary key-value pairs of metadata.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/context.jl#L1-L4">source</a><br/></section><h3><a class="nav-anchor" id="Functions-and-Macros-3" href="#Functions-and-Macros-3">Functions and Macros</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.add!" href="#Dispatcher.add!"><code>Dispatcher.add!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">add!(ctx::DispatchContext, node::DispatchNode) -&gt; DispatchNode</code></pre><p>Add a <code>DispatchNode</code> to the <code>DispatchContext</code>&#39;s graph and record its dependencies in the graph.</p><p>Return the <code>DispatchNode</code> which was added.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/context.jl#L29-L36">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.@dispatch_context" href="#Dispatcher.@dispatch_context"><code>Dispatcher.@dispatch_context</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@dispatch_context begin ... end</code></pre><p>Anonymously create and return a DispatchContext. Accepts a block argument and causes all <code>@op</code> and <code>@node</code> macros within that block to use said DispatchContext.</p><p>See examples in the manual.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/macros.jl#L87-L95">source</a><br/></section><h2><a class="nav-anchor" id="Executors-1" href="#Executors-1">Executors</a></h2><h3><a class="nav-anchor" id="Types-4" href="#Types-4">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.Executor" href="#Dispatcher.Executor"><code>Dispatcher.Executor</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An <code>Executor</code> handles execution of <code>DispatchContext</code>s.</p><p>A type <code>T &lt;: Executor</code> must implement <code>dispatch!(::T, ::DispatchNode)</code> and may optionally implement <code>dispatch!(::T, ::DispatchContext; throw_error=true)</code>.</p><p>The function call tree will look like this when an executor is run:</p><pre><code class="language-none">run!(exec, context)
    prepare!(exec, context)
        prepare!(nodes[i])
    dispatch!(exec, context)
        dispatch!(exec, nodes[i])
            run!(nodes[i])</code></pre><p>NOTE: Currently, it is expected that <code>dispatch!(::T, ::DispatchNode)</code> returns something to wait on (ie: <code>Task</code>, <code>Future</code>, <code>Channel</code>, <code>DispatchNode</code>, etc)</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L3-L21">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.AsyncExecutor" href="#Dispatcher.AsyncExecutor"><code>Dispatcher.AsyncExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>AsyncExecutor</code> is an <code>Executor</code> which schedules a local Julia <code>Task</code> for each <code>DispatchNode</code> and waits for them to complete. <code>AsyncExecutor</code>&#39;s <code>dispatch!</code> method will complete as long as each <code>DispatchNode</code>&#39;s <code>run!</code> method completes and there are no cycles in the computation graph.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L384-L390">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.ParallelExecutor" href="#Dispatcher.ParallelExecutor"><code>Dispatcher.ParallelExecutor</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>ParallelExecutor</code> is an <code>Executor</code> which creates a Julia <code>Task</code> for each <code>DispatchNode</code>, spawns each of those tasks on the processes available to Julia, and waits for them to complete. <code>ParallelExecutor</code>&#39;s <code>dispatch!</code> method will complete as long as each <code>DispatchNode</code>&#39;s <code>run!</code> method completes and there are no cycles in the computation graph.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L419-L426">source</a><br/></section><h3><a class="nav-anchor" id="Functions-and-Macros-4" href="#Functions-and-Macros-4">Functions and Macros</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.prepare!" href="#Dispatcher.prepare!"><code>Dispatcher.prepare!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">prepare!(node::DispatchNode)</code></pre><p>Execute some action on a node before dispatching nodes via an <code>Executor</code>. The default method performs no action.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L57-L62">source</a><br/><div><pre><code class="language-none">prepare!(op::Op)</code></pre><p>Replace an <code>Op</code>&#39;s result field with a fresh, empty one.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L147-L151">source</a><br/><div><pre><code class="language-none">prepare!(node::IndexNode)</code></pre><p>Replace an <code>IndexNode</code>&#39;s result field with a fresh, empty one.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L244-L248">source</a><br/><div><pre><code class="language-none">prepare!(node::IndexNode)</code></pre><p>Replace an <code>CleanupNode</code>&#39;s completion status field with a fresh, empty one.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L319-L323">source</a><br/><div><pre><code class="language-none">prepare!(exec::Executor, ctx::DispatchContext)</code></pre><p>This function <code>prepare!</code>s a context for execution. Call <code>prepare!</code> on each node.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L159-L164">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.run!" href="#Dispatcher.run!"><code>Dispatcher.run!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">run!(node::DispatchNode)</code></pre><p>Execute a node&#39;s action as part of dispatch. The default method performs no action.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L65-L70">source</a><br/><div><pre><code class="language-none">run!(op::Op)</code></pre><p>Fetch an <code>Op</code>&#39;s dependencies and execute its function. Store the result in its <code>result::DeferredFuture</code> field.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L157-L162">source</a><br/><div><pre><code class="language-none">run!(node::IndexNode) -&gt; DeferredFuture</code></pre><p>Fetch data from the <code>IndexNode</code>&#39;s parent at the <code>IndexNode</code>&#39;s index, performing the indexing operation on the process where the data lives. Store the data from that index in a <code>DeferredFuture</code> in the <code>IndexNode</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L253-L259">source</a><br/><div><pre><code class="language-none">run!(node::IndexNode) -&gt; DeferredFuture</code></pre><p>Fetch data from the <code>IndexNode</code>&#39;s parent at the <code>IndexNode</code>&#39;s index, performing the indexing operation on the process where the data lives. Store the data from that index in a <code>DeferredFuture</code> in the <code>IndexNode</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L265-L271">source</a><br/><div><pre><code class="language-none">run!(node::CleanupNode{Op})</code></pre><p>Wait for all of the <code>CleanupNode</code>&#39;s dependencies to finish, then clean up the parent node&#39;s data.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/nodes.jl#L328-L333">source</a><br/><div><pre><code class="language-none">run!(exec, ctx, nodes, input_nodes; input_map, throw_error) -&gt; DispatchResult</code></pre><p>Run a subset of a graph, ending in <code>nodes</code>, and using <code>input_nodes</code>/<code>input_map</code> to replace nodes with fixed values (and ignoring nodes for which all paths descend to <code>input_nodes</code>).</p><p><strong>Arguments</strong></p><ul><li><p><code>exec::Executor</code>: the executor which will execute this context</p></li><li><p><code>ctx::DispatchContext</code>: the context which will be executed</p></li><li><p><code>nodes::AbstractArray{T&lt;:DispatchNode}</code>: the nodes whose results we are interested in</p></li><li><p><code>input_nodes::AbstractArray{T&lt;:DispatchNode}</code>: &quot;root&quot; nodes of the subgraph which will be replaced with their fetched values</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>input_map::Associative=Dict{DispatchNode, Any}()</code>: dict keys are &quot;root&quot; nodes of the subgraph which will be replaced with the dict values</p></li><li><p><code>throw_error::Bool</code>: whether to throw any <code>DependencyError</code>s immediately (see <code>dispatch!</code> documentation for more information)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Vector{DispatchResult}</code>: an array containing a <code>DispatchResult</code> for each node in <code>nodes</code>, in that order.</p></li></ul><p><strong>Throws</strong></p><ul><li><p><code>ExecutorError</code>: if the context&#39;s graph contains a cycle</p></li><li><p><code>CompositeException</code>/<code>DependencyError</code>: see documentation for <code>dispatch!</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L45-L75">source</a><br/><div><pre><code class="language-none">run!(exec::Executor, ctx::DispatchContext; kwargs...)</code></pre><p>The <code>run!</code> function prepares a <code>DispatchContext</code> for dispatch and then dispatches <code>run!</code> calls for all nodes in its graph.</p><p>Users will almost never want to add methods to this function for different <code>Executor</code> subtypes; overriding <code>dispatch!</code> is the preferred pattern.</p><p>Return an array containing a <code>Result{DispatchNode, DependencyError}</code> for each leaf node.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L144-L154">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dispatcher.dispatch!" href="#Dispatcher.dispatch!"><code>Dispatcher.dispatch!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dispatch!(exec::Executor, ctx::DispatchContext; throw_error=true) -&gt; Vector</code></pre><p>The default <code>dispatch!</code> method uses asyncmap over all nodes in the context to call <code>dispatch!(exec, node)</code>. These <code>dispatch!</code> calls for each node are wrapped in various retry and error handling methods.</p><p><strong>Wrapping Details</strong></p><ol><li><p>All nodes are wrapped in a try catch which waits on the value returned from the <code>dispatch!(exec, node)</code> call. Any errors are caught and used to create <code>DependencyError</code>s which are thrown. If no errors are produced then the node is returned.</p><p><strong>NOTE</strong>: All errors thrown by trying to run <code>dispatch!(exec, node)</code> are wrapped in a <code>DependencyError</code>.</p></li><li><p>The aformentioned wrapper function is used in a retry wrapper to rerun failed nodes (up to some limit). The wrapped function will only be retried iff the error produced by <code>dispatch!(::executor, ::DispatchNode</code>) passes one of the retry functions specific to that <code>Executor</code>. By default the <code>AsyncExecutor</code> has no <code>retry_on</code> functions and the <code>ParallelExecutor</code> only has <code>retry_on</code> functions related to the loss of a worker process during execution.</p></li><li><p>A node may enter a failed state if it exits the retry wrapper with an exception. This may occur if an exception is thrown while executing a node and it does not pass any of the <code>retry_on</code> conditions for the <code>Executor</code> or too many attempts to run the node have been made. In the situation where a node has entered a failed state and the node is an <code>Op</code> then the <code>op.result</code> is set to the <code>DependencyError</code>, signifying the node&#39;s failure to any dependent nodes. Finally, if <code>throw_error</code> is true then the <code>DependencyError</code> will be immediately thrown in the current process without allowing other nodes to finish. If <code>throw_error</code> is false then the <code>DependencyError</code> is not thrown and it will be returned in the array of passing and failing nodes.</p></li></ol><p><strong>Arguments</strong></p><ul><li><p><code>exec::Executor</code>: the executor we&#39;re running</p></li><li><p><code>ctx::DispatchContext</code>: the context of nodes to run</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>throw_error::Bool=true</code>: whether or not to throw the <code>DependencyError</code> for failed nodes</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>Vector{Union{DispatchNode, DependencyError}}</code>: a list of <code>DispatchNode</code>s or <code>DependencyError</code>s for failed nodes</p></li></ul><p><strong>Throws</strong></p><ul><li><p><code>dispatch!</code> has the same behaviour on exceptions as <code>asyncmap</code> and <code>pmap</code>. In 0.5 this will throw a <code>CompositeException</code> containing <code>DependencyError</code>s, while in 0.6 this will simply throw the first <code>DependencyError</code>.</p></li></ul><p><strong>Usage</strong></p><p><strong>Example 1</strong></p><p>Assuming we have some uncaught application error:</p><pre><code class="language-julia">exec = AsyncExecutor()
ctx = DispatchContext()
n1 = add!(ctx, Op()-&gt;3)
n2 = add!(ctx, Op()-&gt;4)
failing_node = add!(ctx, Op(()-&gt;throw(ErrorException(&quot;ApplicationError&quot;))))
dep_node = add!(n -&gt; println(n), failing_node)  # This will fail as well</code></pre><p>Then <code>dispatch!(exec, ctx)</code> will throw a <code>DependencyError</code> and <code>dispatch!(exec, ctx; throw_error=false)</code> will return an array of passing nodes and the <code>DependencyError</code>s (ie: <code>[n1, n2, DependencyError(...), DependencyError(...)]</code>).</p><p><strong>Example 2</strong></p><p>Now if we want to retry our node on certain errors we can do:</p><pre><code class="language-julia">exec = AsyncExecutor(5, [e -&gt; isa(e, HttpError) &amp;&amp; e.status == &quot;503&quot;])
ctx = DispatchContext()
n1 = add!(ctx, Op()-&gt;3)
n2 = add!(ctx, Op()-&gt;4)
http_node = add!(ctx, Op(()-&gt;http_get(...)))</code></pre><p>Assuming that the <code>http_get</code> function does not error 5 times the call to <code>dispatch!(exec, ctx)</code> will return [n1, n2, http_node]. If the <code>http_get</code> function either:</p><ol><li><p>fails with a different status code</p></li><li><p>fails with something other than an <code>HttpError</code> or</p></li><li><p>throws an <code>HttpError</code> with status &quot;503&quot; more than 5 times</p></li></ol><p>then we&#39;ll see the same failure behaviour as in the previous example.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L173-L270">source</a><br/><div><pre><code class="language-none">dispatch!(exec::ParallelExecutor, node::DispatchNode) -&gt; Task</code></pre><p><code>dispatch!</code> takes the <code>AsyncExecutor</code> and a <code>DispatchNode</code> to run. The <code>run!</code> method on the node is called within an <code>@async</code> block and the resulting <code>Task</code> is returned. This is the defining method of <code>AsyncExecutor</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L409-L416">source</a><br/><div><pre><code class="language-none">dispatch!(exec::ParallelExecutor, node::DispatchNode) -&gt; Future</code></pre><p><code>dispatch!</code> takes the <code>ParallelExecutor</code> and a <code>DispatchNode</code> to run. The <code>run!</code> method on the node is called within an <code>@spawn</code> block and the resulting <code>Future</code> is returned. This is the defining method of <code>ParallelExecutor</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/invenia/Dispatcher.jl/tree/65ae94620602976d98010e263cd95359c4b9fab5/src/executors.jl#L473-L480">source</a><br/></section><footer><hr/><a class="previous" href="manual.html"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
